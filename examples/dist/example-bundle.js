/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./examples/example.js":
/*!*****************************!*\
  !*** ./examples/example.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/View */ \"./src/View.js\");\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n\tconst height = 605.12;\n  const width = 1161;\n  const container = d3.select(\"#container\");  \n  const svg = container.append(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height]) // width and height hardcoded her\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n  \n  const start = new Date(2023, 5, 12, 10, 15); // year, month (0-indexed), day, hour (00:00-23:59), minute\n  const end = new Date(2023, 6, 14, 16, 30);  \n  const view = new _src_View__WEBPACK_IMPORTED_MODULE_0__.View(start, end, svg);\n});\n\n\n//# sourceURL=webpack://d3-view-timeline/./examples/example.js?");

/***/ }),

/***/ "./src/View.js":
/*!*********************!*\
  !*** ./src/View.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   States: () => (/* binding */ States),\n/* harmony export */   View: () => (/* binding */ View)\n/* harmony export */ });\n/* harmony import */ var _utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utility */ \"./src/utility.js\");\n\n\nconst States = Object.freeze({\n  IDLE: 'idle',\n  DATE_SELECTED: 'date selected',\n  BUILDING_RANGE: 'building range',\n  RANGE_SELECTED: 'range selected'\n})\n\nclass View {\n\n  constructor(startDate, endDate, svgElement) {\n    this.startDate = startDate;\n    this.endDate = endDate;\n    this.svg = svgElement;\n    this.width = 1161;\n    this.height = 605.12;               \n\n    // Declare x and y scales, axis, etc.\n    this.blanket = null;\n    this.clickDelay = 250;\n    this.clickTimer = null;\n    this.currentTooltip = null;\n    this.dragBuffer1 = null;\n    this.dragBuffer2 = null;\n    this.edge1 = null;\n    this.edge2= null;\n    this.enableMouseMove = false;\n    this.existingDiv = null;\n    this.pressTimer = null;\n    this.id = null;     \n    this.isCompareChecked = false;\n    this.isDragging = false;\n    this.isSecondEdgePinned = false;\n    this.isTooltipDisplayed = false;\n    this.isPanning = false;\n    this.lastTransform = d3.zoomIdentity;\n    this.longPress = false;\n    this.mouseX = null;    \n    this.tooltipTimeout = null;        \n    this.toolX = null;\n    this.toolY = null;     \n\n    this.currentState = {\n      state: States.IDLE,\n      date_1: null, // Date() Object\n      date_2: null, // Date() Object\n      x_1: null, // mouse coordinate\n      x_2: null // mouse coordinate\n    }\n\n    let ret = _utility__WEBPACK_IMPORTED_MODULE_0__.setupScales({\n      height: this.height,\n      width: this.width,\n      start: this.startDate,\n      end: this.endDate\n    });\n\n    this.x = ret.x;\n    this.y = ret.y;\n    this.xAxis = ret.xAxis;\n    this.yAxis = ret.yAxis;    \n\n    ret = _utility__WEBPACK_IMPORTED_MODULE_0__.setupSVG({\n      svg: this.svg,\n      xAxis: this.xAxis,\n      yAxis: this.yAxis,\n      height: this.height,\n      width: this.width\n    })\n\n    this.defs = ret.defs;\n    this.gradient = ret.gradient;\n    this.colorStops = ret.colorStops;\n    this.view = ret.view;\n    this.gX = ret.gX;\n    this.gY = ret.gY;\n\n    ret = _utility__WEBPACK_IMPORTED_MODULE_0__.setupZoom({\n      height: this.height,\n      width: this.width,\n      isPanning: this.isPanning,\n      zoomed: this.zoomed.bind(this),\n      setIsPanning: this.setIsPanning.bind(this)\n    })\n\n    this.zoom = ret.zoom;    \n    this.drag = d3.drag()\n      .on(\"start\", this.dragStart.bind(this))\n      .on(\"drag\", this.dragging.bind(this))\n      .on(\"end\", this.dragEnd.bind(this));    \n    \n    this.svg.call(this.zoom);\n    this.svg.on(\"dblclick.zoom\", null);              \n\n    this.view.on(\"pointerdown\", (event) => {\n      //console.log(\"Pointer down listener\"); // DEBUG\n      this.longPress = false;\n      this.handlePointerDown(event);\n    });\n\n    this.view.on(\"pointerup\", (event) => { // TODO putting 'svg' instead of 'view' triggers handleClick when done dragging line\n      //console.log(\"Pointer up listener\"); // DEBUG\n      //console.log(\"longPress: \", this.longPress, \" isPanning: \", this.isPanning);  // DEBUG\n      //console.log(event.target); // DEBUG \n      if(this.isDragging) { return; } // don't handle pointerup event if dragging \n      if(!this.longPress && !this.isPanning){  // regular click => handle by state\n        this.handleClick(event);\n      }      \n      this.handlePointerUp();\n    }); \n\n    this.svg.on(\"mousemove\", (event) => { // attached to svg bc updating blanket element  \n      if(this.enableMouseMove && this.isCompareChecked){                   // that is attached to svg..if its view, choppy and slow\n        this.mouseX = d3.pointer(event)[0];\n        this.updateBlanket();\n      }\n    });\n\n    document.getElementById('resetButton').addEventListener('click', () => {\n      this.resetZoom();\n      this.resetBlanket();\n      this.setIdle(this.currentState);\n      this.printState(this.currentState);\n    });\n  }\n\n// ================================================================================================================================== //\n// ======================================================VVVV EVENT HANDLERS VVVV==================================================== //\n// ================================================================================================================================== //\n\n  handlePointerDown(event) {\n    //console.log(\"pointer down handler\"); // DEBUG \n    this.initialPoint = d3.pointer(event)[0];\n    this.currentPoint = this.initialPoint; // Initialize to initialPoint\n\n    const updatePoint = (event) => {\n      this.currentPoint = d3.pointer(event)[0]; // diff event than outer function event\n    };\n\n    // Listen for any pointer movements to update currentPoint\n    this.view.on(\"pointermove.temp\", updatePoint);\n\n    // Start a timer\n    this.pressTimer = setTimeout(() => {\n      let diff = Math.abs(this.currentPoint - this.initialPoint);\n      //console.log(\"current - initial = \", diff);\n      if (diff < 10) {\n        this.handleLongPress(event);\n        this.longPress = true;\n      }\n      // Remove the temporary \"pointermove\" listener\n      this.view.on(\"pointermove.temp\", null);\n    }, 600);  // 1-second delay\n  }\n\n  handlePointerUp() {\n    //console.log(\"pointer up handler\"); // DEBUG \n    // Clear the timer\n    if (this.pressTimer !== null) {\n      clearTimeout(this.pressTimer);\n      this.pressTimer = null;\n    }\n    // Remove the temporary \"pointermove\" listener just in case\n    this.view.on(\"pointermove.temp\", null);\n    this.initialPoint = null;\n    this.currentPoint = null;\n  }\n\n\n  dragStart(event) {    \n    this.isDragging = true;\n    const target = d3.select(event.sourceEvent.target);\n    this.id = Number(target.attr('id'));\n    console.log(\"start drag...target id: \", this.id);  // DEBUG  \n    let line = this.id === 1 ? this.edge1 : this.edge2;\n    // Change line color to give it a \"highlighted\" look\n    line.attr(\"stroke\", \"red\");\n    // Increase line width to make it more visible\n    line.attr(\"stroke-width\", 4);\n  }\n\n  dragging(event) { // During drag    \n    console.log(\"dragging...\"); // DEBUG\n    this.mouseX = d3.pointer(event)[0]; // where we've dragged to\n    let line = this.id === 1 ? this.edge1 : this.edge2;\n    let rect = this.id === 1 ? this.dragBuffer1 : this.dragBuffer2;\n    line\n      .attr('x1', this.mouseX)\n      .attr('x2', this.mouseX);\n    rect\n      .attr('x', this.mouseX - 5);\n    if(this.blanket){ // blanket changes size with drag if it exists\n      this.updateBlanket();\n    }\n    if(this.existingDiv){ // update \"compare\" div\n      this.existingDiv.attr(\"x\", this.mouseX + 6); // follow drag\n    }    \n  }\n\n  dragEnd(event) {\n    console.log(\"end drag\"); // DEBUG\n    this.mouseX = d3.pointer(event)[0];    \n    if (this.edge1.attr('x1') > this.edge2.attr('x1')){ // edges are out of order, swap them\n      this.swapEdges();\n    }\n    this.updateRangeSelected();\n    this.id = null; // reset global id var for next drag event\n    this.isDragging = false;\n  }  \n\n  handleClick(event) {\n    console.log(\"Handle click\");\n    if(this.isPanning) {\n      console.log(\"Panning not clicking. Return.\");\n      return; // don't register pan as click\n    }\n    this.mouseX = d3.pointer(event)[0];\n\n    switch (this.currentState.state){\n      case States.IDLE:\n        // nothing\n        break;\n      case States.DATE_SELECTED:     \t              \n        if(this.edge1){\n          this.setIdle();\n        } // else: clicked on line or box => do nothing, state remains date_selected\n        break;\n      case States.BUILDING_RANGE:\n        this.setRangeSelected();\n\n        break;\n      case States.RANGE_SELECTED:        \n        // click that was not caught by blanket click listener, must be in background\n        this.resetBlanket();\n        this.setIdle();\n        console.log(\"HandleClick not on blanket...reset to Idle\");\n        break;\n    }\n    // ========== Print State ============ //\n    this.printState();\n    // ========== Print State ============ //   \n  }\n\n  handleLongPress(event) {\n    this.mouseX = d3.pointer(event)[0]; // Mouse X coordinate relative to the SVG element\n    const clickedDate = new Date(this.lastTransform.rescaleX(this.x).invert(this.mouseX));\n    //console.log(\"Long press\");\n    switch (this.currentState.state){\n      case States.IDLE:\n        this.setDateSelected(event, clickedDate);\n        break;\n      case States.DATE_SELECTED:\n        this.updateDateSelected(event, clickedDate);\n        break;\n      case States.BUILDING_RANGE:\n        // nothing yet\n        break;\n      case States.RANGE_SELECTED:\n        // nothing yet\n        break;\n    } // Switch\n\n    // ========== Print State ============ //\n    this.printState();\n    this.longPress = false;\n  }\n\n  handleCheckboxChange(isSelected, event){\n    if(isSelected){\n      this.isCompareChecked = true;\n      this.enableMouseMove = true;\n      this.setBuildingRange();\n    } else {\n      this.isCompareChecked = false;\n      this.enableMouseMove = false;\n      console.log(\"Turning checkbox toggle to off\"); // DEBUG\n      //console.log(\"click target: \", event.target); // DEBUG\n      this.setDateSelected(event, this.currentState.date_1);      \n    }\n    this.printState();\n  }\n\n  updateBlanket() {  \n    switch (this.currentState.state) {\n      case States.BUILDING_RANGE:\n        const x_1 = this.currentState.x_1;\n        const startX = Math.min(x_1,this. mouseX);\n        const endX = Math.max(x_1, this.mouseX);\n        this.blanket.attr(\"x\", startX);\n        this.blanket.attr(\"width\", endX - startX);\n        break;\n      case States.RANGE_SELECTED:\n        const newWidth = this.id === 1 ? this.edge2.attr('x1') - this.mouseX : this.mouseX - this.edge1.attr('x1'); \n        const blanketX = newWidth < 0 ? this.edge2.attr('x1') : this.edge1.attr('x1');\n        const blanketWidth = newWidth < 0 ? Math.abs(newWidth) : newWidth;   \n        this.blanket.attr('x', blanketX);\n        this.blanket.attr('width', blanketWidth);\n        break;\n    }\n  }  \n\n  resetZoom() {\n    this.svg.transition()\n      .duration(750)\n      .call(this.zoom.transform, d3.zoomIdentity);\n  }\n\n// ================================================================================================================================== //\n// ======================================================VVVV STATE HANDLERS VVVV==================================================== //\n// ================================================================================================================================== //     \n\n  setIdle(){\n    if (this.currentState.state === States.DATE_SELECTED){ // DATE_SELECTED => IDLE      \n      // remove existing line\n      this.resetBlanket();\n      this.currentState = {\t// update state \n        ...this.currentState,\n        state: States.IDLE,\n        date_1: null,\n        x_1: null,\n      };       \n    } else if (this.currentState.state === States.RANGE_SELECTED){ // RANGE_SELECTED => IDLE\n      this.currentState = {\t// update state \n        ...this.currentState,\n        state: States.IDLE,\n        date_1: null,\n        date_2: null,\n        x_1: null,\n        x_2: null\n      };      \n    }\n  }\n\n  setDateSelected(event, clickedDate){\n    if(this.currentState.state === States.IDLE){ // IDLE => DATE_SELECTED\n      this.createLine(clickedDate);\n      this.createCheckbox(event);\n      this.currentState = {\n        ...this.currentState,\n        state: States.DATE_SELECTED,\n        date_1: clickedDate,        \n        x_1: this.mouseX\n      };\n    } else if (this.currentState.state === States.BUILDING_RANGE){ // BUILDING_RANGE => DATE_SELECTED\n        // went from blanket (w/o 2nd edge pinned) to just date selected\n        this.blanket.remove();\n        this.blanket = null;\n        this.currentState = {\n        ...this.currentState,\n        state: States.DATE_SELECTED // date_1 & date_2 remain same from prev state\n      };\n      // Re-enable dragging\n      this.dragBuffer1.call(this.drag);\n    }\n  }\n\n  //  Function for when a Date is already selected, and received new longPress => update Line & Div, set date_1\n  updateDateSelected(event, clickedDate){\n    this.edge1 // update line\n      .attr('x1', this.mouseX) // mouseX was updated in function caller\n      .attr('x2', this.mouseX)\n    this.edge1.datum().date = clickedDate;\n    this.dragBuffer1\n      .attr('x', this.mouseX - 5);\n\n    _utility__WEBPACK_IMPORTED_MODULE_0__.updateCheckboxUtil({\n      existingDiv: this.existingDiv,\n      event: event,\n      mouseX: this.mouseX\n    })\n    this.currentState = {\n        ...this.currentState,\n        date_1: clickedDate,\n        x_1: this.mouseX\n    };\n  }\n\n  setBuildingRange(){ // called from handleCheckboxChange    \n    if(this.currentState.state === States.DATE_SELECTED){ \n      // set state to building ... second edge not pinned yet\n      this.currentState = {\n        ...this.currentState,\n        state: States.BUILDING_RANGE  \n        };\n      this.blanket = this.svg.append(\"rect\")\n        .attr(\"x\", this.mouseX)\n        .attr(\"y\", 0)\n        .attr(\"width\", 0)\n        .attr(\"height\", this.height)\n        .attr(\"fill\", \"grey\")\n        .attr(\"opacity\", 0.6);\n      this.blanket.on(\"click\", (event) => { // DEBUG click deselcting \"compare\" registers here incorrectly\n        if(!this.isCompareChecked){\n          console.log(\"Clicking on full blanket\");\n          this.blanketClick(event);\n          return;\n        } else {\n          console.log(\"Blanket click for pinning\");\n          this.mouseX = d3.pointer(event)[0]; // needs to be updated globally\n          this.handleClick(event);  // Manually call the handleClick function\n        }\n        //event.stopPropagation();        \n      });\n      this.dragBuffer1.on('.drag', null); // can't drag edge1 while building range\n    }    \n  }\n\n  setRangeSelected(){\n    // pin second edge \n    this.pinSecondEdge();\n    const x1 = this.edge1.attr('x1');\n    const x2 = this.edge2.attr('x1');\n\n    this.currentState = { // careful to set x_1/x_2 and date_1/date_2 respective to left/right invariant\n      ...this.currentState,\n      state: States.RANGE_SELECTED, \n      x_1: x1,\n      x_2: x2,\n      date_1: this.edge1.datum().date,\n      date_2: this.edge2.datum().date      \n    };\n    this.dragBuffer1.call(this.drag); // allow both edges to be dragged\n    this.dragBuffer2.call(this.drag);\n  }\n\n  updateRangeSelected(){\n    let mouse1 = this.edge1.attr('x1'); //this.id === 1 ? this.mouseX : this.currentState.x_1;\n    let mouse2 = this.edge2.attr('x2'); //this.id === 1 ? this.currentState.x_2 : this.mouseX;\n    let line = this.id === 1 ? this.edge1 : this.edge2;    \n    this.edge1.datum().date = new Date(this.lastTransform.rescaleX(this.x).invert(mouse1));\n    this.edge2.datum().date = new Date(this.lastTransform.rescaleX(this.x).invert(mouse2));\n\n    // Revert the line to its original appearance\n    line.attr(\"stroke\", \"red\");\n    line.attr(\"stroke-width\", 1);\n\n    this.currentState = { // may be updating date_1 OR date_2 \n        ...this.currentState,\n        date_1: this.edge1.datum().date,\n        date_2: this.edge2.datum().date,\n        x_1: mouse1,\n        x_2: mouse2\n    };\n    this.printState();\n  }\n\n// ================================================================================================================================== //\n// =========================================================VVVV UTILITIES VVVV====================================================== //\n// ================================================================================================================================== //     \n\n  pinSecondEdge(){\n    //this.blanket.moveToFront();\n    let clickedDate = new Date(this.lastTransform.rescaleX(this.x).invert(this.mouseX));\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.pinSecondEdgeUtil({\n      blanket: this.blanket,\n      clickedDate: clickedDate,\n      mouseX: this.mouseX,\n      isCompareChecked: this.isCompareChecked,\n      isSecondEdgePinned: this.isSecondEdgePinned,\n      existingDiv: this.existingDiv,\n      height: this.height,   \n      svg: this.svg,\n      edge1: this.edge1,\n      dragBuffer1: this.dragBuffer1\n    });\n    this.isCompareChecked = ret.isCompareChecked;\n    this.isSecondEdgePinned = ret.isSecondEdgePinned;\n    this.existingDiv = ret.existingDiv;\n    this.edge1 = ret.edge1;\n    this.edge2 = ret.edge2;    \n    this.dragBuffer1 = ret.dragBuffer1;\n    this.dragBuffer2 = ret.dragBuffer2;\n  } \n\n  zoomed(event) {    \n    const { transform } = event;\n    this.lastTransform = transform;  // Update the last transform    \n    // this.view.attr(\"transform\", transform); // TODO not needed. Makes view size exceed svg on zoom and messes w/ coords\n    // changing this to svg gets weird as well probs b/c transform is already applied to svg \n    this.gX.call(this.xAxis.scale(this.lastTransform.rescaleX(this.x)));\n    this.gY.call(this.yAxis.scale(this.lastTransform.rescaleY(this.y)));    \n\n    if(this.edge1 || this.edge2){\n      this.transformLine();\n    }\n    // Update positions of blanket edge(s)\n    if (this.blanket){\n      this.transformBlanket();\n    }        \n  } // zoomed\n\n  transformLine(){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.transformLineUtil({\n      edge1: this.edge1,\n      edge2: this.edge2,\n      lastTransform: this.lastTransform,\n      x: this.x,\n      dragBuffer1: this.dragBuffer1,\n      dragBuffer2: this.dragBuffer2,\n      existingDiv: this.existingDiv\n    })\n    this.currentState = {\n      ...this.currentState,\n      x_1: ret.newX1  \n    }\n  }\n\n  transformBlanket(){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.transformBlanketUtil({\n      currentState: this.currentState,\n      mouseX: this.mouseX,\n      lastTransform: this.lastTransform,\n      isSecondEdgePinned: this.isSecondEdgePinned,\n      blanket: this.blanket,\n      isTooltipDisplayed: this.isTooltipDisplayed,\n      toolX: this.toolX,\n      toolY: this.toolY,\n      currentTooltip: this.currentTooltip,\n      x: this.x,\n\n    })\n    this.isSecondEdgePinned = ret.isSecondEdgePinned;\n    this.isTooltipDisplayed = ret.isTooltipDisplayed;\n    this.currentState = {\n      ...ret.currentState\n    };\n  }\n\n  blanketClick(event){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.blanketClickUtil({\n      mouseX: this.mouseX,\n      blanket: this.blanket,\n      isTooltipDisplayed: this.isTooltipDisplayed,\n      toolX: this.toolX,\n      toolY: this.toolY,\n      currentState: this.currentState,\n      currentTooltip: this.currentTooltip,\n      tooltipTimeout: this.tooltipTimeout,\n      event: event,\n      setTooltipDisplayed: this.setTooltipDisplayed.bind(this)\n    })    \n    this.mouseX = ret.mouseX;   \n    this.isTooltipDisplayed = ret.isTooltipDisplayed;\n    this.toolX = ret.toolX;\n    this.toolY = ret.toolY;\n    this.currentTooltip = ret.currentTooltip;\n    this.tooltipTimeout = ret.tooltipTimeout;    // TODO ensure tooltip listener is setting things as expected\n    let click = ret.click;\n    let blanketX = ret.blanketX;\n    let blanketWidth = ret.blanketWidth;\n   \n    if (click < blanketX || click > (blanketX + blanketWidth)) { // clicked out of blanket => remove it\n      this.setIdle(); // set Idle state\n      this.resetBlanket();      \n    }\n  }    \n\n  printState(){\n    _utility__WEBPACK_IMPORTED_MODULE_0__.printStateUtil({ // no variables get updates, don't worry about pass by value\n      state: this.currentState\n    })\n  }  \n\n  resetBlanket() { // NOTE when reassigning obj reference in util func, only reference copy updated\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.resetBlanketUtil({\n      blanket: this.blanket,\n      edge1: this.edge1,\n      edge2: this.edge2,\n      existingDiv: this.existingDiv,\n      dragBuffer1: this.dragBuffer1,\n      dragBuffer2: this.dragBuffer2,\n      tooltipTimeout: this.tooltipTimeout,\n      currentTooltip: this.currentTooltip,\n      isTooltipDisplayed: this.isTooltipDisplayed\n    })\n    this.blanket = ret.blanket;\n    this.edge1 = ret.edge1;\n    this.edge2 = ret.edge2;\n    this.existingDiv = ret.existingDiv;\n    this.dragBuffer1 = ret.dragBuffer1;\n    this.dragBuffer2 = ret.dragBuffer2;\n    this.tooltipTimeout = ret.tooltipTimeout;\n    this.isTooltipDisplayed = ret.isTooltipDisplayed;\n    this.currentTooltip = ret.currentTooltip;\n\n    this.isCompareChecked = false;\n    this.isSecondEdgePinned = false;\n    }\n\n  createCheckbox(event){    \n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.createCheckboxUtil({\n      event: event,\n      existingDiv: this.existingDiv,\n      handleCheckboxChange: this.handleCheckboxChange.bind(this),\n      svg: this.svg,\n      mouseX: this.mouseX\n    })\n    this.existingDiv = ret.existingDiv;    \n  }\n\n  createLine(clickedDate){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.createLineUtil({\n      mouseX: this.mouseX,\n      svg: this.svg,\n      height: this.height,\n      clickedDate: clickedDate,\n      dragBuffer1: this.dragBuffer1,\n      drag: this.drag\n    })\n    this.edge1 = ret.edge1;\n    this.dragBuffer1 = ret.dragBuffer1;\n  }\n\n  swapEdges(){\n    let line = this.id === 1 ? this.edge1 : this.edge2;\n    let newDate = new Date(this.lastTransform.rescaleX(this.x).invert(line.attr('x1')));\n    line.datum().date = newDate; // update whichever line has been moved\n\n    const tempX = this.edge1.attr('x1');\n    const tempData = this.edge1.datum().date;\n    const tempDragX = this.dragBuffer1.attr('x');        \n    // swap edge1 & 2    \n    this.edge1\n      .attr('x1', this.edge2.attr('x1'))\n      .attr('x2', this.edge2.attr('x2'))\n    this.edge1.datum().date = this.edge2.datum().date;\n    this.dragBuffer1\n      .attr('x', this.dragBuffer2.attr('x'));\n    this.edge2\n      .attr('x1', tempX)\n      .attr('x2', tempX)\n    this.edge2.datum().date = tempData;\n    this.dragBuffer2\n      .attr('x', tempDragX);\n    console.log(\"edge1: \", this.edge1.attr('x1'), \" Date: \", this.edge1.datum().date); // DEBUG\n    console.log(\"edge2: \", this.edge2.attr('x2'), \" Date: \", this.edge2.datum().date); // DEBUG\n  }\n\n  setIsPanning(setTo){\n    this.isPanning = setTo ? true : false;\n  }\n\n  setTooltipDisplayed(setTo){\n    this.isTooltipDisplayed = setTo ? true : false; \n  }\n} // End View \n\n\n//# sourceURL=webpack://d3-view-timeline/./src/View.js?");

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blanketClickUtil: () => (/* binding */ blanketClickUtil),\n/* harmony export */   clickOutUtil: () => (/* binding */ clickOutUtil),\n/* harmony export */   createCheckboxUtil: () => (/* binding */ createCheckboxUtil),\n/* harmony export */   createLineUtil: () => (/* binding */ createLineUtil),\n/* harmony export */   pinSecondEdgeUtil: () => (/* binding */ pinSecondEdgeUtil),\n/* harmony export */   printStateUtil: () => (/* binding */ printStateUtil),\n/* harmony export */   resetBlanketUtil: () => (/* binding */ resetBlanketUtil),\n/* harmony export */   setupSVG: () => (/* binding */ setupSVG),\n/* harmony export */   setupScales: () => (/* binding */ setupScales),\n/* harmony export */   setupZoom: () => (/* binding */ setupZoom),\n/* harmony export */   transformBlanketUtil: () => (/* binding */ transformBlanketUtil),\n/* harmony export */   transformLineUtil: () => (/* binding */ transformLineUtil),\n/* harmony export */   updateCheckboxUtil: () => (/* binding */ updateCheckboxUtil)\n/* harmony export */ });\n/*\r\nIMPORTANT:\r\nThe parameters passed into these utility functions are passed-by-value if they are primitive types, and by reference otherwise.\r\nIf an entire reference is reassigned (like ptr = null) from within this file, only the local reference is reassigned and not original object.\r\nAttributes of an object can be updated using the local reference and reflected in View.js, but if reference is reassigned, the member variable must\r\nbe updated in View.js using return value of utility funtion. \r\n*/\r\n\r\nfunction pinSecondEdgeUtil(params){\r\n  let {blanket, clickedDate, mouseX, isCompareChecked, isSecondEdgePinned, existingDiv, height, svg, edge1, dragBuffer1} = params;    \r\n  const firstX = edge1.attr('x1');\r\n  let edge2 = null;\r\n  let dragBuffer2 = null;\r\n\r\n  if (isCompareChecked) {\r\n    isSecondEdgePinned = true;\r\n    const startX = Math.min(firstX, mouseX);\r\n    const endX = Math.max(firstX, mouseX);\r\n    const date1 = firstX < mouseX ? edge1.datum().date : clickedDate;\r\n    const date2 = firstX < mouseX ? clickedDate : edge1.datum().date;\r\n\r\n    if (blanket) { // Update the blanket div\r\n      let date = date1;\r\n      blanket\r\n        .attr(\"x\", startX)\r\n        .attr(\"width\", endX - startX);\r\n      edge1 // make edge1 the leftmost edge\r\n        .attr('x1', startX)\r\n        .attr('x2', startX)      \r\n      edge1.datum({date});\r\n      date = date2;\r\n      edge2 = svg.append('line') // make edge2 the rightmost edge\r\n        .attr('x1', endX)\r\n        .attr('x2', endX)\r\n        .attr('y1', 0)\r\n        .attr('y2', height)\r\n        .attr('stroke', 'red')\r\n        .attr('stroke-width', 1)\r\n        .attr('class', 'vertical-line')\r\n        .attr('id', 2);    \r\n      edge2.datum({date});\r\n        \r\n      dragBuffer2 = svg.append(\"rect\")\r\n        .attr(\"x\", endX - 5) // 5 pixels to the left of the line\r\n        .attr(\"y\", 0)\r\n        .attr(\"width\", 10) // 10 pixels width (5 on each side of the line)\r\n        .attr(\"height\", height)\r\n        .attr(\"opacity\", 0) // invisible\r\n        .attr('id', 2);\r\n      dragBuffer2.style('cursor', 'pointer');\r\n\r\n      dragBuffer1.attr(\"x\", startX - 5); // TODO just to make sure its in right spot?\r\n      console.log(\"date1: \", date1);\r\n      console.log(\"date2: \", date2);\r\n    }\r\n    // Remove the compare checkbox\r\n    if (existingDiv) {\r\n      existingDiv.remove();\r\n      existingDiv = null;\r\n      isCompareChecked = false;\r\n    }  \r\n  }    \r\n  return { // returning variables that are passed-by-value and references reassigned\r\n    existingDiv,\r\n    isCompareChecked,\r\n    isSecondEdgePinned,\r\n    edge1,\r\n    edge2,\r\n    dragBuffer1,\r\n    dragBuffer2\r\n  };\r\n}\r\n\r\nfunction transformLineUtil(params){\r\n  let {edge1, edge2, lastTransform, x, dragBuffer1, dragBuffer2, existingDiv} = params;\r\n  const newX1 = edge1 !== null ? lastTransform.rescaleX(x)(edge1.datum().date) : null;\r\n  const newX2 = edge2 !== null ? lastTransform.rescaleX(x)(edge2.datum().date) : null;\r\n  if(newX1){\r\n    edge1\r\n      .attr('x1', newX1)\r\n      .attr('x2', newX1); // TODO edge1 and dragBuffer1 disappearing sometimes upon blanketClick\r\n    dragBuffer1.attr('x', newX1 - 5); // Transform the dragBuffer as well\r\n  }\r\n  if(newX2){\r\n    edge2\r\n      .attr('x1', newX2)\r\n      .attr('x2', newX2);\r\n    dragBuffer2.attr('x', newX2 - 5);\r\n  }  \r\n  if(existingDiv){\r\n    existingDiv.attr('x', newX1 + 6);\r\n  }\r\n  return {newX1, newX2};\r\n}\r\n\r\nfunction transformBlanketUtil(params){\r\n  let {currentState, mouseX, lastTransform, isSecondEdgePinned, blanket, isTooltipDisplayed, toolX, toolY, currentTooltip, x} = params;\r\n  const date_1 = currentState.date_1;\r\n  const date_2 = currentState.date_2;\r\n  const x_1 = lastTransform.rescaleX(x)(date_1);\r\n  const x_2 = lastTransform.rescaleX(x)(date_2);\r\n  currentState = {\r\n    ...currentState,\r\n    x_1: x_1, // only updating mouse coord's here because of zoom, date still the same\r\n    x_2: x_2\r\n  };\r\n  if(!isSecondEdgePinned){\r\n    const blanketX = Math.min(mouseX, x_1); // there is no x_2 yet\r\n    blanket.attr(\"x\", blanketX);\r\n    blanket.attr('width', Math.abs(mouseX - x_1));\r\n  } else { \r\n    blanket.attr(\"x\", Math.min(x_1, x_2));\r\n    blanket.attr(\"width\", Math.abs(x_2 - x_1)); \r\n    if (isTooltipDisplayed) { // tooltip can only be displayed if full blanket\r\n      const tooltipX = toolX * lastTransform.k + lastTransform.x;\r\n      const tooltipY = toolY * lastTransform.k + lastTransform.y;\r\n      currentTooltip.style.left = `${tooltipX}px`;\r\n      currentTooltip.style.top = `${tooltipY}px`;\r\n      }\r\n  }  \t   \r\n  return { \r\n    isSecondEdgePinned,\r\n    isTooltipDisplayed,\r\n    currentState\r\n  } \r\n}\r\n\r\nfunction blanketClickUtil(params){\r\n  let {mouseX, blanket, isTooltipDisplayed, toolX, toolY, currentState, currentTooltip, tooltipTimeout, event, setTooltipDisplayed} = params;\r\n  mouseX = d3.pointer(event)[0];\r\n  let blanketX = parseFloat(blanket.attr(\"x\"));\r\n  let blanketWidth = parseFloat(blanket.attr(\"width\"));\r\n  let click = parseFloat(mouseX);\r\n  // Round to 4 decimal places\r\n  blanketX = parseFloat(blanketX.toFixed(4));\r\n  blanketWidth = parseFloat(blanketWidth.toFixed(4));\r\n  click = parseFloat(click.toFixed(4));\r\n\r\n  let ret = { // primitive types are passed by value not reference like objects, need to return them for updates        \r\n      mouseX,\r\n      isTooltipDisplayed,\r\n      toolX,\r\n      toolY,\r\n      currentTooltip,\r\n      tooltipTimeout,\r\n      click,\r\n      blanketX,\r\n      blanketWidth        \r\n  };\r\n\r\n  if (click >= blanketX && click <= (blanketX + blanketWidth)) { // clicked inside blanket => display toolTip\r\n    if(!isTooltipDisplayed){\r\n      // Create tooltip\r\n      const tooltip = document.createElement('div');\r\n      tooltip.style.position = 'absolute';\r\n      tooltip.style.left = `${event.pageX}px`;\r\n      tooltip.style.top = `${event.pageY - 30}px`; // Above the cursor\r\n      tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';\r\n      tooltip.style.color = 'white';\r\n      tooltip.style.borderRadius = '4px';\r\n      tooltip.style.padding = '5px';\r\n\r\n      ret.toolX = event.pageX;\r\n      ret.toolY = event.pageY - 30;\r\n\r\n      const timeFormat = d3.timeFormat(\"%A %B %d, %I:%M %p\");\r\n      const date_1 = currentState.date_1;\r\n      const date_2 = currentState.date_2;\r\n      const startTime = timeFormat(date_1 < date_2 ? date_1 : date_2);\r\n      const endTime = timeFormat(date_1 < date_2 ? date_2 : date_1);       \r\n\r\n      tooltip.innerHTML = `From:  ${startTime}<br>To:  ${endTime}`;\r\n      document.body.appendChild(tooltip);\r\n      ret.currentTooltip = tooltip;\r\n      \r\n      ret.isTooltipDisplayed = true;   \t\r\n      ret.tooltipTimeout = setTimeout(() => { // Remove the tooltip after 2 seconds\r\n        tooltip.remove();\r\n        setTooltipDisplayed(false);\r\n        //ret.isTooltipDisplayed = false;\r\n        tooltipTimeout = null;\r\n        ret.tooltipTimeout = null;\r\n      }, 4000);\r\n    }\r\n        \r\n    return ret; // Exit the function early\r\n  }\r\n  return ret;\r\n}\r\n  \r\nfunction printStateUtil(params){\r\n  let {state} = params;\r\n  let data1 = null;\r\n  let data2 = null;\r\n  let data3 = null;\r\n  let data4 = null;\r\n  if(state.date_1){\r\n    data1 = state.date_1.toLocaleString();\r\n  }\r\n  if(state.date_2){\r\n    data2 = state.date_2.toLocaleString();\r\n  }\r\n  if(state.x_1){\r\n    data3 = state.x_1;\r\n  }\r\n  if(state.x_2){\r\n    data4 = state.x_2;\r\n  }\r\n  console.log(state.state, \"Date_1: \", data1, \"x_1: \", data3, \"Date_2: \", data2,  \"x_2: \", data4);\r\n}\r\n\r\nfunction resetBlanketUtil(params) { // Reset everything relating to blanket       \r\n  let {blanket, edge1, edge2, existingDiv, dragBuffer1, dragBuffer2, tooltipTimeout, currentTooltip, isTooltipDisplayed} = params;\r\n  if(blanket){\r\n    //console.log(\"blanket \", blanket);\r\n    blanket.remove();\r\n    blanket = null;        \r\n  }\r\n  if(edge1){        \r\n    edge1.remove();        \r\n    edge1 = null;\r\n  }\r\n  if(edge2){\r\n    edge2.remove();\r\n    edge2 = null;\r\n  }\r\n  if (existingDiv) {        \r\n    existingDiv.remove();        \r\n    existingDiv = null;\r\n  }   \r\n  if(dragBuffer1){        \r\n    dragBuffer1.remove();        \r\n    dragBuffer1 = null;\r\n  }\r\n  if(dragBuffer2){\r\n    dragBuffer2.remove();\r\n    dragBuffer2 = null;\r\n  }\r\n  // Clear tooltip and its timeout if they exist\r\n  if (tooltipTimeout) {        \r\n    clearTimeout(tooltipTimeout);        \r\n    if (currentTooltip) {\r\n      currentTooltip.remove(); // Remove the tooltip using higher-scope reference        \r\n      isTooltipDisplayed = false;\r\n      currentTooltip = null;\r\n      }\r\n  }\r\n  return {\r\n    blanket,\r\n    edge1,\r\n    edge2,\r\n    existingDiv,\r\n    dragBuffer1,\r\n    dragBuffer2,\r\n    tooltipTimeout,\r\n    isTooltipDisplayed,\r\n    currentTooltip\r\n  }\r\n}\r\n\r\nfunction createCheckboxUtil(params){\r\n  let {event, existingDiv, handleCheckboxChange, svg, mouseX} = params;\r\n  const foreignObject = svg.append(\"foreignObject\")\r\n    .attr('x', mouseX + 6)\r\n    .attr('y', d3.pointer(event)[1] - 23)\r\n    .attr(\"width\", 120)\r\n    .attr(\"height\", 45);\r\n\r\n  const toggleLabel = foreignObject.append(\"xhtml:div\")\r\n    .attr(\"class\", \"toggle-label\")\r\n    .text(\"Compare?\")      \r\n    \r\n  toggleLabel.on(\"click\", (event) => {\r\n    const isSelected = d3.select(event.currentTarget).classed(\"selected\");\r\n    handleCheckboxChange(!isSelected, event);\r\n    d3.select(event.currentTarget).classed(\"selected\", !isSelected); // This toggles the class on the clicked element\r\n  });  \r\n  existingDiv = foreignObject; // Store div reference for future use\r\n  return {existingDiv};\r\n}\r\n\r\nfunction updateCheckboxUtil(params){\r\n  let {existingDiv, event, mouseX} = params;\r\n  existingDiv\r\n    .attr('x', mouseX + 6)\r\n    .attr('y', d3.pointer(event)[1] - 23)\r\n}\r\n\r\nfunction createLineUtil(params){\r\n  let {mouseX, svg, height, clickedDate, dragBuffer1, drag} = params;\r\n  const mouse = mouseX;\r\n  let edge1 = null;    \r\n  if(!edge1){\r\n    edge1 = svg.append('line')\r\n      .attr('x1', mouse)\r\n      .attr('x2', mouse)\r\n      .attr('y1', 0)\r\n      .attr('y2', height)\r\n      .attr('stroke', 'red')\r\n      .attr('stroke-width', 1)\r\n      .attr('class', 'vertical-line')\r\n      .attr('id', 1);\r\n    const date = clickedDate;\r\n    edge1.datum({date});\r\n    // Invisible buffer for dragging\r\n    dragBuffer1 = svg.append(\"rect\")\r\n      .attr(\"x\", mouse - 5) // 5 pixels to the left of the line\r\n      .attr(\"y\", 0)\r\n      .attr(\"width\", 10) // 10 pixels width (5 on each side of the line)\r\n      .attr(\"height\", height)\r\n      .attr(\"opacity\", 0) // invisible\r\n      .attr('id', 1); \r\n    dragBuffer1.call(drag);  // Attach drag behavior to buffer\r\n    dragBuffer1.style('cursor', 'pointer');\r\n  }\r\n  return {edge1, dragBuffer1};\r\n}\r\n\r\nfunction clickOutUtil(params){ // only used for state == date_selected\r\n  let {event} = params;\r\n  let classString = '';\r\n  if (event.target instanceof SVGElement) {\r\n    classString = event.target.getAttribute('class') || '';\r\n  } else {\r\n    classString = '';\r\n  }\r\n\r\n  console.log(\"clickOut event.target: \", event.target); // DEBUG\r\n\r\n  if (classString !== 'vertical-line' && classString !== 'checkbox-div') {\r\n    // return true (yes clicked on backgrounnd..should reset)\r\n    return true;\r\n  } else{ // return false (clicked on line or checkbox, don't reset)    \t\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction setupScales(params){\r\n  let {height, width, start, end} = params;\r\n  // Set up SVG, scales, and axes.\r\n  let x = d3.scaleTime()\r\n    .domain([start, end])\r\n    .range([0, width])\r\n\r\n  let y = d3.scaleLinear()\r\n    .domain([0, 600])\r\n    .range([-1, height + 1])\r\n\r\n  let xAxis = d3.axisBottom(x)\r\n    .tickSize(height)\r\n    .tickPadding(8 - height)\r\n    .ticks(8)\r\n\r\n  let yAxis = d3.axisRight(y)\r\n    .ticks(10)\r\n    .tickSize(width)\r\n    .tickPadding(8 - width)\r\n  \r\n  return {x, y, xAxis, yAxis};\r\n}\r\n\r\nfunction setupSVG(params){\r\n  let {svg, xAxis, yAxis, height, width} = params;\r\n  // Define gradient\r\n  const defs = svg.append(\"defs\");\r\n  const gradient = defs.append(\"linearGradient\")\r\n    .attr(\"id\", \"gradient\")\r\n    .attr(\"x1\", \"0%\")\r\n    .attr(\"y1\", \"0%\")\r\n    .attr(\"x2\", \"100%\")\r\n    .attr(\"y2\", \"100%\");\r\n\r\n  const colorStops = [\r\n    { offset: \"0.0%\", color: \"#2c7bb6\" },\r\n    { offset: \"12.5%\", color: \"#00a6ca\" },\r\n    { offset: \"25.0%\", color: \"#00ccbc\" },\r\n    { offset: \"37.5%\", color: \"#90eb9d\" },\r\n    { offset: \"50.0%\", color: \"#ffff8c\" },\r\n    { offset: \"62.5%\", color: \"#f9d057\" },\r\n    { offset: \"75.0%\", color: \"#f29e2e\" },\r\n    { offset: \"87.5%\", color: \"#e76818\" },\r\n    { offset: \"100.0%\", color: \"#d7191c\" }\r\n  ];\r\n\r\n  // Add color stops to gradient (can define these stops in the array)\r\n  gradient.selectAll(\"stop\")\r\n    .data(colorStops)\r\n    .enter().append(\"stop\")\r\n    .attr(\"offset\", d => d.offset)\r\n    .attr(\"stop-color\", d => d.color);\r\n\r\n  const view = svg.append(\"rect\")\r\n    .attr(\"class\", \"view\")\r\n    .attr(\"x\", 0.5)\r\n    .attr(\"y\", 0.5)\r\n    .attr(\"width\", width +1)\r\n    .attr(\"height\", height +1)\r\n\r\n  const gX = svg.append(\"g\")\r\n    .attr(\"class\", \"axis axis--x\")   \t\r\n    .call(xAxis);\r\n\r\n  const gY = svg.append(\"g\")\r\n    .attr(\"class\", \"axis axis--y\")\r\n    .call(yAxis);    \r\n  return {defs, gradient, colorStops, view, gX, gY}\r\n}\r\n\r\nfunction setupZoom(params){\r\n  let {height, width, isPanning, zoomed, setIsPanning} = params;\r\n\r\n  let zoom = d3.zoom()\r\n    .scaleExtent([1, 100])\r\n    .translateExtent([[-25, -25], [width, height]])\r\n    .on(\"start\", () => {\r\n      //console.log(\"zoom start\")  ;\r\n      setIsPanning(false);\r\n    })\r\n    .on(\"end\", () => {   \r\n      //console.log(\"zoom end\")  ;     \r\n      if(!isPanning){\r\n        // handleClick\r\n      }\r\n      setIsPanning(false);\r\n    })\r\n    .on(\"zoom\", (event) => {\r\n      let d = event.transform;\r\n      if (d.x !== 0 || d.y !== 0 || d.k !== 1) {\r\n          setIsPanning(true); // set to true if transformation detected\r\n          //console.log(\"setting panning to true\")  ;;\r\n      }\r\n      zoomed(event);\r\n    })\r\n  return {zoom};\r\n}\r\n\n\n//# sourceURL=webpack://d3-view-timeline/./src/utility.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./examples/example.js");
/******/ 	
/******/ })()
;
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./examples/example.js":
/*!*****************************!*\
  !*** ./examples/example.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/View */ \"./src/View.js\");\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n\tconst height = 605.12;\n  const width = 1161;\n  const container = d3.select(\"#container\");  \n  const svg = container.append(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height]) // width and height hardcoded her\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n  \n  const start = new Date(2023, 5, 12, 10, 15); // year, month (0-indexed), day, hour (00:00-23:59), minute\n  const end = new Date(2023, 6, 14, 16, 30);  \n  const view = new _src_View__WEBPACK_IMPORTED_MODULE_0__.View(start, end, svg);\n});\n\n\n//# sourceURL=webpack://d3-view-timeline/./examples/example.js?");

/***/ }),

/***/ "./src/View.js":
/*!*********************!*\
  !*** ./src/View.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   States: () => (/* binding */ States),\n/* harmony export */   View: () => (/* binding */ View)\n/* harmony export */ });\n/* harmony import */ var _utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utility */ \"./src/utility.js\");\n\n\nconst States = Object.freeze({\n  IDLE: 'idle',\n  DATE_SELECTED: 'date selected',\n  BUILDING_RANGE: 'building range',\n  RANGE_SELECTED: 'range selected'\n})\n\nclass View {\n\n  constructor(startDate, endDate, svgElement) {\n    this.startDate = startDate;\n    this.endDate = endDate;\n    this.svg = svgElement;\n    this.width = 1161;\n    this.height = 605.12;               \n\n    // Declare x and y scales, axis, etc.\n    this.blanket = null;\n    this.clickDelay = 250;\n    this.clickTimer = null;\n    this.currentTooltip = null;\n    this.dragBuffer1 = null;\n    this.dragBuffer2 = null;\n    this.edge1 = null;\n    this.edge2= null;\n    this.enableMouseMove = false;\n    this.existingDiv = null;\n    this.pressTimer = null;\n    this.id = null;     \n    this.isCompareChecked = false;\n    this.isDragging = false;\n    this.isSecondEdgePinned = false;\n    this.isTooltipDisplayed = false;\n    this.isPanning = false;\n    this.lastTransform = d3.zoomIdentity;\n    this.longPress = false;\n    this.mouseX = null;    \n    this.tooltipTimeout = null;        \n    this.toolX = null;\n    this.toolY = null;     \n\n    this.currentState = {\n      state: States.IDLE,\n      date_1: null, // Date() Object\n      date_2: null, // Date() Object\n      x_1: null, // mouse coordinate\n      x_2: null // mouse coordinate\n    }\n\n    let ret = _utility__WEBPACK_IMPORTED_MODULE_0__.setupScales({\n      height: this.height,\n      width: this.width,\n      start: this.startDate,\n      end: this.endDate\n    });\n\n    this.x = ret.x;\n    this.y = ret.y;\n    this.xAxis = ret.xAxis;\n    this.yAxis = ret.yAxis;    \n\n    ret = _utility__WEBPACK_IMPORTED_MODULE_0__.setupSVG({\n      svg: this.svg,\n      xAxis: this.xAxis,\n      yAxis: this.yAxis,\n      height: this.height,\n      width: this.width\n    })\n\n    this.defs = ret.defs;\n    this.gradient = ret.gradient;\n    this.colorStops = ret.colorStops;\n    this.view = ret.view;\n    this.gX = ret.gX;\n    this.gY = ret.gY;\n\n    ret = _utility__WEBPACK_IMPORTED_MODULE_0__.setupZoom({\n      height: this.height,\n      width: this.width,\n      isPanning: this.isPanning,\n      zoomed: this.zoomed.bind(this),\n      setIsPanning: this.setIsPanning.bind(this)\n    })\n\n    this.zoom = ret.zoom;    \n    this.drag = d3.drag()\n      .on(\"start\", this.dragStart.bind(this))\n      .on(\"drag\", this.dragging.bind(this))\n      .on(\"end\", this.dragEnd.bind(this));    \n    \n    this.svg.call(this.zoom);\n    this.svg.on(\"dblclick.zoom\", null);              \n\n    this.view.on(\"pointerdown\", (event) => {\n      //console.log(\"Pointer down listener\"); // DEBUG\n      this.longPress = false;\n      this.handlePointerDown(event);\n    });\n\n    this.view.on(\"pointerup\", (event) => { // TODO putting 'svg' instead of 'view' triggers handleClick when done dragging line\n      //console.log(\"Pointer up listener\"); // DEBUG\n      //console.log(\"longPress: \", this.longPress, \" isPanning: \", this.isPanning);  // DEBUG\n      //console.log(event.target); // DEBUG \n      if(this.isDragging) { return; } // don't handle pointerup event if dragging \n      if(!this.longPress && !this.isPanning){  // regular click => handle by state\n        this.handleClick(event);\n      }      \n      this.handlePointerUp();\n    }); \n\n    this.svg.on(\"mousemove\", (event) => { // attached to svg bc updating blanket element  \n      if(this.enableMouseMove && this.isCompareChecked){                   // that is attached to svg..if its view, choppy and slow\n        this.mouseX = d3.pointer(event)[0];\n        this.updateBlanket();\n      }\n    });\n\n    document.getElementById('resetButton').addEventListener('click', () => {\n      this.resetZoom();\n      this.resetBlanket();\n      this.setIdle(this.currentState);\n      this.printState(this.currentState);\n    });\n  }\n\n// ================================================================================================================================== //\n// ======================================================VVVV EVENT HANDLERS VVVV==================================================== //\n// ================================================================================================================================== //\n\n  handlePointerDown(event) {\n    //console.log(\"pointer down handler\"); // DEBUG \n    this.initialPoint = d3.pointer(event)[0];\n    this.currentPoint = this.initialPoint; // Initialize to initialPoint\n\n    const updatePoint = (event) => {\n      this.currentPoint = d3.pointer(event)[0]; // diff event than outer function event\n    };\n\n    // Listen for any pointer movements to update currentPoint\n    this.view.on(\"pointermove.temp\", updatePoint);\n\n    // Start a timer\n    this.pressTimer = setTimeout(() => {\n      let diff = Math.abs(this.currentPoint - this.initialPoint);\n      //console.log(\"current - initial = \", diff);\n      if (diff < 10) {\n        this.handleLongPress(event);\n        this.longPress = true;\n      }\n      // Remove the temporary \"pointermove\" listener\n      this.view.on(\"pointermove.temp\", null);\n    }, 600);  // 1-second delay\n  }\n\n  handlePointerUp() {\n    //console.log(\"pointer up handler\"); // DEBUG \n    // Clear the timer\n    if (this.pressTimer !== null) {\n      clearTimeout(this.pressTimer);\n      this.pressTimer = null;\n    }\n    // Remove the temporary \"pointermove\" listener just in case\n    this.view.on(\"pointermove.temp\", null);\n    this.initialPoint = null;\n    this.currentPoint = null;\n  }\n\n\n  dragStart(event) {    \n    this.isDragging = true;\n    const target = d3.select(event.sourceEvent.target);\n    this.id = Number(target.attr('id'));\n    console.log(\"start drag...target id: \", this.id);  // DEBUG  \n    let line = this.id === 1 ? this.edge1 : this.edge2;\n    // Change line color to give it a \"highlighted\" look\n    line.attr(\"stroke\", \"red\");\n    // Increase line width to make it more visible\n    line.attr(\"stroke-width\", 4);\n  }\n\n  dragging(event) { // During drag    \n    console.log(\"dragging...\"); // DEBUG\n    this.mouseX = d3.pointer(event)[0]; // where we've dragged to\n    let line = this.id === 1 ? this.edge1 : this.edge2;\n    let rect = this.id === 1 ? this.dragBuffer1 : this.dragBuffer2;\n    line\n      .attr('x1', this.mouseX)\n      .attr('x2', this.mouseX);\n    rect\n      .attr('x', this.mouseX - 5);\n    if(this.blanket){ // blanket changes size with drag if it exists\n      this.updateBlanket();\n    }\n    if(this.existingDiv){ // update \"compare\" div\n      this.existingDiv.attr(\"x\", this.mouseX + 6); // follow drag\n    }    \n  }\n\n  dragEnd(event) {\n    console.log(\"end drag\"); // DEBUG\n    this.mouseX = d3.pointer(event)[0];    \n    if (this.edge1.attr('x1') > this.edge2.attr('x1')){ // edges are out of order, swap them\n      this.swapEdges();\n    }\n    this.updateRangeSelected();\n    this.id = null; // reset global id var for next drag event\n    this.isDragging = false;\n  }  \n\n  handleClick(event) {\n    console.log(\"Handle click\");\n    if(this.isPanning) {\n      console.log(\"Panning not clicking. Return.\");\n      return; // don't register pan as click\n    }\n    this.mouseX = d3.pointer(event)[0];\n\n    switch (this.currentState.state){\n      case States.IDLE:\n        // nothing\n        break;\n      case States.DATE_SELECTED:     \t              \n        if(this.edge1){\n          this.setIdle();\n        } // else: clicked on line or box => do nothing, state remains date_selected\n        break;\n      case States.BUILDING_RANGE:\n        this.setRangeSelected();\n\n        break;\n      case States.RANGE_SELECTED:        \n        // click that was not caught by blanket click listener, must be in background\n        this.resetBlanket();\n        this.setIdle();\n        console.log(\"HandleClick not on blanket...reset to Idle\");\n        break;\n    }\n    // ========== Print State ============ //\n    this.printState();\n    // ========== Print State ============ //   \n  }\n\n  handleLongPress(event) {\n    this.mouseX = d3.pointer(event)[0]; // Mouse X coordinate relative to the SVG element\n    const clickedDate = new Date(this.lastTransform.rescaleX(this.x).invert(this.mouseX));\n    //console.log(\"Long press\");\n    switch (this.currentState.state){\n      case States.IDLE:\n        this.setDateSelected(event, clickedDate);\n        break;\n      case States.DATE_SELECTED:\n        this.updateDateSelected(event, clickedDate);\n        break;\n      case States.BUILDING_RANGE:\n        // nothing yet\n        break;\n      case States.RANGE_SELECTED:\n        // nothing yet\n        break;\n    } // Switch\n\n    // ========== Print State ============ //\n    this.printState();\n    this.longPress = false;\n  }\n\n  handleCheckboxChange(isSelected, event){\n    if(isSelected){\n      this.isCompareChecked = true;\n      this.enableMouseMove = true;\n      this.setBuildingRange();\n    } else {\n      this.isCompareChecked = false;\n      this.enableMouseMove = false;\n      console.log(\"Turning checkbox toggle to off\"); // DEBUG\n      //console.log(\"click target: \", event.target); // DEBUG\n      this.setDateSelected(event, this.currentState.date_1);      \n    }\n    this.printState();\n  }\n\n  updateBlanket() {  \n    switch (this.currentState.state) {\n      case States.BUILDING_RANGE:\n        const x_1 = this.currentState.x_1;\n        const startX = Math.min(x_1,this. mouseX);\n        const endX = Math.max(x_1, this.mouseX);\n        this.blanket.attr(\"x\", startX);\n        this.blanket.attr(\"width\", endX - startX);\n        break;\n      case States.RANGE_SELECTED:\n        const newWidth = this.id === 1 ? this.edge2.attr('x1') - this.mouseX : this.mouseX - this.edge1.attr('x1'); \n        const blanketX = newWidth < 0 ? this.edge2.attr('x1') : this.edge1.attr('x1');\n        const blanketWidth = newWidth < 0 ? Math.abs(newWidth) : newWidth;   \n        this.blanket.attr('x', blanketX);\n        this.blanket.attr('width', blanketWidth);\n        break;\n    }\n  }  \n\n  resetZoom() {\n    this.svg.transition()\n      .duration(750)\n      .call(this.zoom.transform, d3.zoomIdentity);\n  }\n\n// ================================================================================================================================== //\n// ======================================================VVVV STATE HANDLERS VVVV==================================================== //\n// ================================================================================================================================== //     \n\n  setIdle(){\n    if (this.currentState.state === States.DATE_SELECTED){ // DATE_SELECTED => IDLE      \n      // remove existing line\n      this.resetBlanket();\n      this.currentState = {\t// update state \n        ...this.currentState,\n        state: States.IDLE,\n        date_1: null,\n        x_1: null,\n      };       \n    } else if (this.currentState.state === States.RANGE_SELECTED){ // RANGE_SELECTED => IDLE\n      this.currentState = {\t// update state \n        ...this.currentState,\n        state: States.IDLE,\n        date_1: null,\n        date_2: null,\n        x_1: null,\n        x_2: null\n      };      \n    }\n  }\n\n  setDateSelected(event, clickedDate){\n    if(this.currentState.state === States.IDLE){ // IDLE => DATE_SELECTED\n      this.createLine(clickedDate);\n      this.createCheckbox(event);\n      this.currentState = {\n        ...this.currentState,\n        state: States.DATE_SELECTED,\n        date_1: clickedDate,        \n        x_1: this.mouseX\n      };\n    } else if (this.currentState.state === States.BUILDING_RANGE){ // BUILDING_RANGE => DATE_SELECTED\n        // went from blanket (w/o 2nd edge pinned) to just date selected\n        this.blanket.remove();\n        this.blanket = null;\n        this.currentState = {\n        ...this.currentState,\n        state: States.DATE_SELECTED // date_1 & date_2 remain same from prev state\n      };\n      // Re-enable dragging\n      this.dragBuffer1.call(this.drag);\n    }\n  }\n\n  //  Function for when a Date is already selected, and received new longPress => update Line & Div, set date_1\n  updateDateSelected(event, clickedDate){\n    this.edge1 // update line\n      .attr('x1', this.mouseX) // mouseX was updated in function caller\n      .attr('x2', this.mouseX)\n    this.edge1.datum().date = clickedDate;\n    this.dragBuffer1\n      .attr('x', this.mouseX - 5);\n\n    _utility__WEBPACK_IMPORTED_MODULE_0__.updateCheckboxUtil({\n      existingDiv: this.existingDiv,\n      event: event,\n      mouseX: this.mouseX\n    })\n    this.currentState = {\n        ...this.currentState,\n        date_1: clickedDate,\n        x_1: this.mouseX\n    };\n  }\n\n  setBuildingRange(){ // called from handleCheckboxChange    \n    if(this.currentState.state === States.DATE_SELECTED){ \n      // set state to building ... second edge not pinned yet\n      this.currentState = {\n        ...this.currentState,\n        state: States.BUILDING_RANGE  \n        };\n      this.blanket = this.svg.append(\"rect\")\n        .attr(\"x\", this.mouseX)\n        .attr(\"y\", 0)\n        .attr(\"width\", 0)\n        .attr(\"height\", this.height)\n        .attr(\"fill\", \"grey\")\n        .attr(\"opacity\", 0.6);\n      this.blanket.on(\"click\", (event) => { // DEBUG click deselcting \"compare\" registers here incorrectly\n        if(!this.isCompareChecked){\n          console.log(\"Clicking on full blanket\");\n          this.blanketClick(event);\n          return;\n        } else {\n          console.log(\"Blanket click for pinning\");\n          this.mouseX = d3.pointer(event)[0]; // needs to be updated globally\n          this.handleClick(event);  // Manually call the handleClick function\n        }\n        //event.stopPropagation();        \n      });\n      this.dragBuffer1.on('.drag', null); // can't drag edge1 while building range\n    }    \n  }\n\n  setRangeSelected(){\n    // pin second edge \n    this.pinSecondEdge();\n    const x1 = this.edge1.attr('x1');\n    const x2 = this.edge2.attr('x1');\n\n    this.currentState = { // careful to set x_1/x_2 and date_1/date_2 respective to left/right invariant\n      ...this.currentState,\n      state: States.RANGE_SELECTED, \n      x_1: x1,\n      x_2: x2,\n      date_1: this.edge1.datum().date,\n      date_2: this.edge2.datum().date      \n    };\n    this.dragBuffer1.call(this.drag); // allow both edges to be dragged\n    this.dragBuffer2.call(this.drag);\n  }\n\n  updateRangeSelected(){\n    let mouse1 = this.edge1.attr('x1'); //this.id === 1 ? this.mouseX : this.currentState.x_1;\n    let mouse2 = this.edge2.attr('x2'); //this.id === 1 ? this.currentState.x_2 : this.mouseX;\n    let line = this.id === 1 ? this.edge1 : this.edge2;    \n    this.edge1.datum().date = new Date(this.lastTransform.rescaleX(this.x).invert(mouse1));\n    this.edge2.datum().date = new Date(this.lastTransform.rescaleX(this.x).invert(mouse2));\n\n    // Revert the line to its original appearance\n    line.attr(\"stroke\", \"red\");\n    line.attr(\"stroke-width\", 1);\n\n    this.currentState = { // may be updating date_1 OR date_2 \n        ...this.currentState,\n        date_1: this.edge1.datum().date,\n        date_2: this.edge2.datum().date,\n        x_1: mouse1,\n        x_2: mouse2\n    };\n    this.printState();\n  }\n\n// ================================================================================================================================== //\n// =========================================================VVVV UTILITIES VVVV====================================================== //\n// ================================================================================================================================== //     \n\n  pinSecondEdge(){\n    //this.blanket.moveToFront();\n    let clickedDate = new Date(this.lastTransform.rescaleX(this.x).invert(this.mouseX));\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.pinSecondEdgeUtil({\n      blanket: this.blanket,\n      clickedDate: clickedDate,\n      mouseX: this.mouseX,\n      isCompareChecked: this.isCompareChecked,\n      isSecondEdgePinned: this.isSecondEdgePinned,\n      existingDiv: this.existingDiv,\n      height: this.height,   \n      svg: this.svg,\n      edge1: this.edge1,\n      dragBuffer1: this.dragBuffer1\n    });\n    this.isCompareChecked = ret.isCompareChecked;\n    this.isSecondEdgePinned = ret.isSecondEdgePinned;\n    this.existingDiv = ret.existingDiv;\n    this.edge1 = ret.edge1;\n    this.edge2 = ret.edge2;    \n    this.dragBuffer1 = ret.dragBuffer1;\n    this.dragBuffer2 = ret.dragBuffer2;\n  } \n\n  zoomed(event) {    \n    const { transform } = event;\n    this.lastTransform = transform;  // Update the last transform    \n    // this.view.attr(\"transform\", transform); // TODO not needed. Makes view size exceed svg on zoom and messes w/ coords\n    // changing this to svg gets weird as well probs b/c transform is already applied to svg \n    this.gX.call(this.xAxis.scale(this.lastTransform.rescaleX(this.x)));\n    this.gY.call(this.yAxis.scale(this.lastTransform.rescaleY(this.y)));    \n\n    if(this.edge1 || this.edge2){\n      this.transformLine();\n    }\n    // Update positions of blanket edge(s)\n    if (this.blanket){\n      this.transformBlanket();\n    }        \n  } // zoomed\n\n  transformLine(){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.transformLineUtil({\n      edge1: this.edge1,\n      edge2: this.edge2,\n      lastTransform: this.lastTransform,\n      x: this.x,\n      dragBuffer1: this.dragBuffer1,\n      dragBuffer2: this.dragBuffer2,\n      existingDiv: this.existingDiv\n    })\n    this.currentState = {\n      ...this.currentState,\n      x_1: ret.newX1  \n    }\n  }\n\n  transformBlanket(){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.transformBlanketUtil({\n      currentState: this.currentState,\n      mouseX: this.mouseX,\n      lastTransform: this.lastTransform,\n      isSecondEdgePinned: this.isSecondEdgePinned,\n      blanket: this.blanket,\n      isTooltipDisplayed: this.isTooltipDisplayed,\n      toolX: this.toolX,\n      toolY: this.toolY,\n      currentTooltip: this.currentTooltip,\n      x: this.x,\n\n    })\n    this.isSecondEdgePinned = ret.isSecondEdgePinned;\n    this.isTooltipDisplayed = ret.isTooltipDisplayed;\n    this.currentState = {\n      ...ret.currentState\n    };\n  }\n\n  blanketClick(event){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.blanketClickUtil({\n      mouseX: this.mouseX,\n      blanket: this.blanket,\n      isTooltipDisplayed: this.isTooltipDisplayed,\n      toolX: this.toolX,\n      toolY: this.toolY,\n      currentState: this.currentState,\n      currentTooltip: this.currentTooltip,\n      tooltipTimeout: this.tooltipTimeout,\n      event: event,\n      setTooltipDisplayed: this.setTooltipDisplayed.bind(this)\n    })    \n    this.mouseX = ret.mouseX;   \n    this.isTooltipDisplayed = ret.isTooltipDisplayed;\n    this.toolX = ret.toolX;\n    this.toolY = ret.toolY;\n    this.currentTooltip = ret.currentTooltip;\n    this.tooltipTimeout = ret.tooltipTimeout;    // TODO ensure tooltip listener is setting things as expected\n    let click = ret.click;\n    let blanketX = ret.blanketX;\n    let blanketWidth = ret.blanketWidth;\n   \n    if (click < blanketX || click > (blanketX + blanketWidth)) { // clicked out of blanket => remove it\n      this.setIdle(); // set Idle state\n      this.resetBlanket();      \n    }\n  }    \n\n  printState(){\n    _utility__WEBPACK_IMPORTED_MODULE_0__.printStateUtil({ // no variables get updates, don't worry about pass by value\n      state: this.currentState\n    })\n  }  \n\n  resetBlanket() { // NOTE when reassigning obj reference in util func, only reference copy updated\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.resetBlanketUtil({\n      blanket: this.blanket,\n      edge1: this.edge1,\n      edge2: this.edge2,\n      existingDiv: this.existingDiv,\n      dragBuffer1: this.dragBuffer1,\n      dragBuffer2: this.dragBuffer2,\n      tooltipTimeout: this.tooltipTimeout,\n      currentTooltip: this.currentTooltip,\n      isTooltipDisplayed: this.isTooltipDisplayed\n    })\n    this.blanket = ret.blanket;\n    this.edge1 = ret.edge1;\n    this.edge2 = ret.edge2;\n    this.existingDiv = ret.existingDiv;\n    this.dragBuffer1 = ret.dragBuffer1;\n    this.dragBuffer2 = ret.dragBuffer2;\n    this.tooltipTimeout = ret.tooltipTimeout;\n    this.isTooltipDisplayed = ret.isTooltipDisplayed;\n    this.currentTooltip = ret.currentTooltip;\n\n    this.isCompareChecked = false;\n    this.isSecondEdgePinned = false;\n    }\n\n  createCheckbox(event){    \n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.createCheckboxUtil({\n      event: event,\n      existingDiv: this.existingDiv,\n      handleCheckboxChange: this.handleCheckboxChange.bind(this),\n      svg: this.svg,\n      mouseX: this.mouseX\n    })\n    this.existingDiv = ret.existingDiv;    \n  }\n\n  createLine(clickedDate){\n    const ret = _utility__WEBPACK_IMPORTED_MODULE_0__.createLineUtil({\n      mouseX: this.mouseX,\n      svg: this.svg,\n      height: this.height,\n      clickedDate: clickedDate,\n      dragBuffer1: this.dragBuffer1,\n      drag: this.drag\n    })\n    this.edge1 = ret.edge1;\n    this.dragBuffer1 = ret.dragBuffer1;\n  }\n\n  swapEdges(){\n    let line = this.id === 1 ? this.edge1 : this.edge2;\n    let newDate = new Date(this.lastTransform.rescaleX(this.x).invert(line.attr('x1')));\n    line.datum().date = newDate; // update whichever line has been moved\n\n    const tempX = this.edge1.attr('x1');\n    const tempData = this.edge1.datum().date;\n    const tempDragX = this.dragBuffer1.attr('x');        \n    // swap edge1 & 2    \n    this.edge1\n      .attr('x1', this.edge2.attr('x1'))\n      .attr('x2', this.edge2.attr('x2'))\n    this.edge1.datum().date = this.edge2.datum().date;\n    this.dragBuffer1\n      .attr('x', this.dragBuffer2.attr('x'));\n    this.edge2\n      .attr('x1', tempX)\n      .attr('x2', tempX)\n    this.edge2.datum().date = tempData;\n    this.dragBuffer2\n      .attr('x', tempDragX);\n    console.log(\"edge1: \", this.edge1.attr('x1'), \" Date: \", this.edge1.datum().date); // DEBUG\n    console.log(\"edge2: \", this.edge2.attr('x2'), \" Date: \", this.edge2.datum().date); // DEBUG\n  }\n\n  setIsPanning(setTo){\n    this.isPanning = setTo ? true : false;\n  }\n\n  setTooltipDisplayed(setTo){\n    this.isTooltipDisplayed = setTo ? true : false; \n  }\n} // End View \n\n\n//# sourceURL=webpack://d3-view-timeline/./src/View.js?");

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blanketClickUtil: () => (/* binding */ blanketClickUtil),\n/* harmony export */   clickOutUtil: () => (/* binding */ clickOutUtil),\n/* harmony export */   createCheckboxUtil: () => (/* binding */ createCheckboxUtil),\n/* harmony export */   createLineUtil: () => (/* binding */ createLineUtil),\n/* harmony export */   pinSecondEdgeUtil: () => (/* binding */ pinSecondEdgeUtil),\n/* harmony export */   printStateUtil: () => (/* binding */ printStateUtil),\n/* harmony export */   resetBlanketUtil: () => (/* binding */ resetBlanketUtil),\n/* harmony export */   setupSVG: () => (/* binding */ setupSVG),\n/* harmony export */   setupScales: () => (/* binding */ setupScales),\n/* harmony export */   setupZoom: () => (/* binding */ setupZoom),\n/* harmony export */   transformBlanketUtil: () => (/* binding */ transformBlanketUtil),\n/* harmony export */   transformLineUtil: () => (/* binding */ transformLineUtil),\n/* harmony export */   updateCheckboxUtil: () => (/* binding */ updateCheckboxUtil)\n/* harmony export */ });\n/*\r\nIMPORTANT:\r\nThe parameters passed into these utility functions are passed-by-value if they are primitive types, and by reference otherwise.\r\nIf an entire reference is reassigned (like ptr = null) from within this file, only the local reference is reassigned and not original object.\r\nAttributes of an object can be updated using the local reference and reflected in View.js, but if reference is reassigned, the member variable must\r\nbe updated in View.js using return value of utility funtion. \r\n*/\r\n\r\nfunction pinSecondEdgeUtil(params){\r\n  let {blanket, clickedDate, mouseX, isCompareChecked, isSecondEdgePinned, existingDiv, height, svg, edge1, dragBuffer1} = params;    \r\n  const firstX = edge1.attr('x1');\r\n  let edge2 = null;\r\n  let dragBuffer2 = null;\r\n\r\n  if (isCompareChecked) {\r\n    isSecondEdgePinned = true;\r\n    const startX = Math.min(firstX, mouseX);\r\n    const endX = Math.max(firstX, mouseX);\r\n    const date1 = firstX < mouseX ? edge1.datum().date : clickedDate;\r\n    const date2 = firstX < mouseX ? clickedDate : edge1.datum().date;\r\n\r\n    if (blanket) { // Update the blanket div\r\n      let date = date1;\r\n      blanket\r\n        .attr(\"x\", startX)\r\n        .attr(\"width\", endX - startX);\r\n      edge1 // make edge1 the leftmost edge\r\n        .attr('x1', startX)\r\n        .attr('x2', startX)      \r\n      edge1.datum({date});\r\n      date = date2;\r\n      edge2 = svg.append('line') // make edge2 the rightmost edge\r\n        .attr('x1', endX)\r\n        .attr('x2', endX)\r\n        .attr('y1', 0)\r\n        .attr('y2', height)\r\n        .attr('stroke', 'red')\r\n        .attr('stroke-width', 1)\r\n        .attr('class', 'vertical-line')\r\n        .attr('id', 2);    \r\n      edge2.datum({date});\r\n        \r\n      dragBuffer2 = svg.append(\"rect\")\r\n        .attr(\"x\", endX - 5) // 5 pixels to the left of the line\r\n        .attr(\"y\", 0)\r\n        .attr(\"width\", 10) // 10 pixels width (5 on each side of the line)\r\n        .attr(\"height\", height)\r\n        .attr(\"opacity\", 0) // invisible\r\n        .attr('id', 2);\r\n      dragBuffer2.style('cursor', 'pointer');\r\n\r\n      dragBuffer1.attr(\"x\", startX - 5); // TODO just to make sure its in right spot?\r\n      console.log(\"date1: \", date1);\r\n      console.log(\"date2: \", date2);\r\n    }\r\n    // Remove the compare checkbox\r\n    if (existingDiv) {\r\n      existingDiv.remove();\r\n      existingDiv = null;\r\n      isCompareChecked = false;\r\n    }  \r\n  }    \r\n  return { // returning variables that are passed-by-value and references reassigned\r\n    existingDiv,\r\n    isCompareChecked,\r\n    isSecondEdgePinned,\r\n    edge1,\r\n    edge2,\r\n    dragBuffer1,\r\n    dragBuffer2\r\n  };\r\n}\r\n\r\nfunction transformLineUtil(params){\r\n  let {edge1, edge2, lastTransform, x, dragBuffer1, dragBuffer2, existingDiv} = params;\r\n  const newX1 = edge1 !== null ? lastTransform.rescaleX(x)(edge1.datum().date) : null;\r\n  const newX2 = edge2 !== null ? lastTransform.rescaleX(x)(edge2.datum().date) : null;\r\n  if(newX1){\r\n    edge1\r\n      .attr('x1', newX1)\r\n      .attr('x2', newX1); // TODO edge1 and dragBuffer1 disappearing sometimes upon blanketClick\r\n    dragBuffer1.attr('x', newX1 - 5); // Transform the dragBuffer as well\r\n  }\r\n  if(newX2){\r\n    edge2\r\n      .attr('x1', newX2)\r\n      .attr('x2', newX2);\r\n    dragBuffer2.attr('x', newX2 - 5);\r\n  }  \r\n  if(existingDiv){\r\n    existingDiv.attr('x', newX1 + 6);\r\n  }\r\n  return {newX1, newX2};\r\n}\r\n\r\nfunction transformBlanketUtil(params){\r\n  let {currentState, mouseX, lastTransform, isSecondEdgePinned, blanket, isTooltipDisplayed, toolX, toolY, currentTooltip, x} = params;\r\n  const date_1 = currentState.date_1;\r\n  const date_2 = currentState.date_2;\r\n  const x_1 = lastTransform.rescaleX(x)(date_1);\r\n  const x_2 = lastTransform.rescaleX(x)(date_2);\r\n  currentState = {\r\n    ...currentState,\r\n    x_1: x_1, // only updating mouse coord's here because of zoom, date still the same\r\n    x_2: x_2\r\n  };\r\n  if(!isSecondEdgePinned){\r\n    const blanketX = Math.min(mouseX, x_1); // there is no x_2 yet\r\n    blanket.attr(\"x\", blanketX);\r\n    blanket.attr('width', Math.abs(mouseX - x_1));\r\n  } else { \r\n    blanket.attr(\"x\", Math.min(x_1, x_2));\r\n    blanket.attr(\"width\", Math.abs(x_2 - x_1)); \r\n    if (isTooltipDisplayed) { // tooltip can only be displayed if full blanket\r\n      const tooltipX = toolX * lastTransform.k + lastTransform.x;\r\n      const tooltipY = toolY * lastTransform.k + lastTransform.y;\r\n      currentTooltip.style.left = `${tooltipX}px`;\r\n      currentTooltip.style.top = `${tooltipY}px`;\r\n      }\r\n  }  \t   \r\n  return { \r\n    isSecondEdgePinned,\r\n    isTooltipDisplayed,\r\n    currentState\r\n  } \r\n}\r\n\r\nfunction blanketClickUtil(params){\r\n  let {mouseX, blanket, isTooltipDisplayed, toolX, toolY, currentState, currentTooltip, tooltipTimeout, event, setTooltipDisplayed} = params;\r\n  mouseX = d3.pointer(event)[0];\r\n  let blanketX = parseFloat(blanket.attr(\"x\"));\r\n  let blanketWidth = parseFloat(blanket.attr(\"width\"));\r\n  let click = parseFloat(mouseX);\r\n  // Round to 4 decimal places\r\n  blanketX = parseFloat(blanketX.toFixed(4));\r\n  blanketWidth = parseFloat(blanketWidth.toFixed(4));\r\n  click = parseFloat(click.toFixed(4));\r\n\r\n  let ret = { // primitive types are passed by value not reference like objects, need to return them for updates        \r\n      mouseX,\r\n      isTooltipDisplayed,\r\n      toolX,\r\n      toolY,\r\n      currentTooltip,\r\n      tooltipTimeout,\r\n      click,\r\n      blanketX,\r\n      blanketWidth        \r\n  };\r\n\r\n  if (click >= blanketX && click <= (blanketX + blanketWidth)) { // clicked inside blanket => display toolTip\r\n    if(!isTooltipDisplayed){\r\n      // Create tooltip\r\n      const tooltip = document.createElement('div');\r\n      tooltip.style.position = 'absolute';\r\n      tooltip.style.left = `${event.pageX}px`;\r\n      tooltip.style.top = `${event.pageY - 30}px`; // Above the cursor\r\n      tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';\r\n      tooltip.style.color = 'white';\r\n      tooltip.style.borderRadius = '4px';\r\n      tooltip.style.padding = '5px';\r\n\r\n      ret.toolX = event.pageX;\r\n      ret.toolY = event.pageY - 30;\r\n\r\n      const timeFormat = d3.timeFormat(\"%A %B %d, %I:%M %p\");\r\n      const date_1 = currentState.date_1;\r\n      const date_2 = currentState.date_2;\r\n      const startTime = timeFormat(date_1 < date_2 ? date_1 : date_2);\r\n      const endTime = timeFormat(date_1 < date_2 ? date_2 : date_1);       \r\n\r\n      tooltip.innerHTML = `From:  ${startTime}<br>To:  ${endTime}`;\r\n      document.body.appendChild(tooltip);\r\n      ret.currentTooltip = tooltip;\r\n      \r\n      ret.isTooltipDisplayed = true;   \t\r\n      ret.tooltipTimeout = setTimeout(() => { // Remove the tooltip after 2 seconds\r\n        tooltip.remove();\r\n        setTooltipDisplayed(false);\r\n        //ret.isTooltipDisplayed = false;\r\n        tooltipTimeout = null;\r\n        ret.tooltipTimeout = null;\r\n      }, 4000);\r\n    }\r\n        \r\n    return ret; // Exit the function early\r\n  }\r\n  return ret;\r\n}\r\n  \r\nfunction printStateUtil(params){\r\n  let {state} = params;\r\n  let data1 = null;\r\n  let data2 = null;\r\n  let data3 = null;\r\n  let data4 = null;\r\n  if(state.date_1){\r\n    data1 = state.date_1.toLocaleString();\r\n  }\r\n  if(state.date_2){\r\n    data2 = state.date_2.toLocaleString();\r\n  }\r\n  if(state.x_1){\r\n    data3 = state.x_1;\r\n  }\r\n  if(state.x_2){\r\n    data4 = state.x_2;\r\n  }\r\n  console.log(state.state, \"Date_1: \", data1, \"x_1: \", data3, \"Date_2: \", data2,  \"x_2: \", data4);\r\n}\r\n\r\nfunction resetBlanketUtil(params) { // Reset everything relating to blanket       \r\n  let {blanket, edge1, edge2, existingDiv, dragBuffer1, dragBuffer2, tooltipTimeout, currentTooltip, isTooltipDisplayed} = params;\r\n  if(blanket){\r\n    //console.log(\"blanket \", blanket);\r\n    blanket.remove();\r\n    blanket = null;        \r\n  }\r\n  if(edge1){        \r\n    edge1.remove();        \r\n    edge1 = null;\r\n  }\r\n  if(edge2){\r\n    edge2.remove();\r\n    edge2 = null;\r\n  }\r\n  if (existingDiv) {        \r\n    existingDiv.remove();        \r\n    existingDiv = null;\r\n  }   \r\n  if(dragBuffer1){        \r\n    dragBuffer1.remove();        \r\n    dragBuffer1 = null;\r\n  }\r\n  if(dragBuffer2){\r\n    dragBuffer2.remove();\r\n    dragBuffer2 = null;\r\n  }\r\n  // Clear tooltip and its timeout if they exist\r\n  if (tooltipTimeout) {        \r\n    clearTimeout(tooltipTimeout);        \r\n    if (currentTooltip) {\r\n      currentTooltip.remove(); // Remove the tooltip using higher-scope reference        \r\n      isTooltipDisplayed = false;\r\n      currentTooltip = null;\r\n      }\r\n  }\r\n  return {\r\n    blanket,\r\n    edge1,\r\n    edge2,\r\n    existingDiv,\r\n    dragBuffer1,\r\n    dragBuffer2,\r\n    tooltipTimeout,\r\n    isTooltipDisplayed,\r\n    currentTooltip\r\n  }\r\n}\r\n\r\nfunction createCheckboxUtil(params){\r\n  let {event, existingDiv, handleCheckboxChange, svg, mouseX} = params;\r\n  const foreignObject = svg.append(\"foreignObject\")\r\n    .attr('x', mouseX + 6)\r\n    .attr('y', d3.pointer(event)[1] - 23)\r\n    .attr(\"width\", 120)\r\n    .attr(\"height\", 45);\r\n\r\n  const toggleLabel = foreignObject.append(\"xhtml:div\")\r\n    .attr(\"class\", \"toggle-label\")\r\n    .text(\"Compare?\")      \r\n    \r\n  toggleLabel.on(\"click\", (event) => {\r\n    const isSelected = d3.select(event.currentTarget).classed(\"selected\");\r\n    handleCheckboxChange(!isSelected, event);\r\n    d3.select(event.currentTarget).classed(\"selected\", !isSelected); // This toggles the class on the clicked element\r\n  });  \r\n  existingDiv = foreignObject; // Store div reference for future use\r\n  return {existingDiv};\r\n}\r\n\r\nfunction updateCheckboxUtil(params){\r\n  let {existingDiv, event, mouseX} = params;\r\n  existingDiv\r\n    .attr('x', mouseX + 6)\r\n    .attr('y', d3.pointer(event)[1] - 23)\r\n}\r\n\r\nfunction createLineUtil(params){\r\n  let {mouseX, svg, height, clickedDate, dragBuffer1, drag} = params;\r\n  const mouse = mouseX;\r\n  let edge1 = null;    \r\n  if(!edge1){\r\n    edge1 = svg.append('line')\r\n      .attr('x1', mouse)\r\n      .attr('x2', mouse)\r\n      .attr('y1', 0)\r\n      .attr('y2', height)\r\n      .attr('stroke', 'red')\r\n      .attr('stroke-width', 1)\r\n      .attr('class', 'vertical-line')\r\n      .attr('id', 1);\r\n    const date = clickedDate;\r\n    edge1.datum({date});\r\n    // Invisible buffer for dragging\r\n    dragBuffer1 = svg.append(\"rect\")\r\n      .attr(\"x\", mouse - 5) // 5 pixels to the left of the line\r\n      .attr(\"y\", 0)\r\n      .attr(\"width\", 10) // 10 pixels width (5 on each side of the line)\r\n      .attr(\"height\", height)\r\n      .attr(\"opacity\", 0) // invisible\r\n      .attr('id', 1); \r\n    dragBuffer1.call(drag);  // Attach drag behavior to buffer\r\n    dragBuffer1.style('cursor', 'pointer');\r\n  }\r\n  return {edge1, dragBuffer1};\r\n}\r\n\r\nfunction clickOutUtil(params){ // only used for state == date_selected\r\n  let {event} = params;\r\n  let classString = '';\r\n  if (event.target instanceof SVGElement) {\r\n    classString = event.target.getAttribute('class') || '';\r\n  } else {\r\n    classString = '';\r\n  }\r\n\r\n  console.log(\"clickOut event.target: \", event.target); // DEBUG\r\n\r\n  if (classString !== 'vertical-line' && classString !== 'checkbox-div') {\r\n    // return true (yes clicked on backgrounnd..should reset)\r\n    return true;\r\n  } else{ // return false (clicked on line or checkbox, don't reset)    \t\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction setupScales(params){\r\n  let {height, width, start, end} = params;\r\n  // Set up SVG, scales, and axes.\r\n  let x = d3.scaleTime()\r\n    .domain([start, end])\r\n    .range([0, width])\r\n\r\n  let y = d3.scaleLinear()\r\n    .domain([0, 600])\r\n    .range([-1, height + 1])\r\n\r\n  let xAxis = d3.axisBottom(x)\r\n    .tickSize(height)\r\n    .tickPadding(8 - height)\r\n    .ticks(8)\r\n\r\n  let yAxis = d3.axisRight(y)\r\n    .ticks(10)\r\n    .tickSize(width)\r\n    .tickPadding(8 - width)\r\n  \r\n  return {x, y, xAxis, yAxis};\r\n}\r\n\r\nfunction setupSVG(params){\r\n  let {svg, xAxis, yAxis, height, width} = params;\r\n  // Define gradient\r\n  const defs = svg.append(\"defs\");\r\n  const gradient = defs.append(\"linearGradient\")\r\n    .attr(\"id\", \"gradient\")\r\n    .attr(\"x1\", \"0%\")\r\n    .attr(\"y1\", \"0%\")\r\n    .attr(\"x2\", \"100%\")\r\n    .attr(\"y2\", \"100%\");\r\n\r\n  const colorStops = [\r\n    { offset: \"0.0%\", color: \"#2c7bb6\" },\r\n    { offset: \"12.5%\", color: \"#00a6ca\" },\r\n    { offset: \"25.0%\", color: \"#00ccbc\" },\r\n    { offset: \"37.5%\", color: \"#90eb9d\" },\r\n    { offset: \"50.0%\", color: \"#ffff8c\" },\r\n    { offset: \"62.5%\", color: \"#f9d057\" },\r\n    { offset: \"75.0%\", color: \"#f29e2e\" },\r\n    { offset: \"87.5%\", color: \"#e76818\" },\r\n    { offset: \"100.0%\", color: \"#d7191c\" }\r\n  ];\r\n\r\n  // Add color stops to gradient (can define these stops in the array)\r\n  gradient.selectAll(\"stop\")\r\n    .data(colorStops)\r\n    .enter().append(\"stop\")\r\n    .attr(\"offset\", d => d.offset)\r\n    .attr(\"stop-color\", d => d.color);\r\n\r\n  const view = svg.append(\"rect\")\r\n    .attr(\"class\", \"view\")\r\n    .attr(\"x\", 0.5)\r\n    .attr(\"y\", 0.5)\r\n    .attr(\"width\", width +1)\r\n    .attr(\"height\", height +1)\r\n\r\n  const gX = svg.append(\"g\")\r\n    .attr(\"class\", \"axis axis--x\")   \t\r\n    .call(xAxis);\r\n\r\n  const gY = svg.append(\"g\")\r\n    .attr(\"class\", \"axis axis--y\")\r\n    .call(yAxis);    \r\n  return {defs, gradient, colorStops, view, gX, gY}\r\n}\r\n\r\nfunction setupZoom(params){\r\n  let {height, width, isPanning, zoomed, setIsPanning} = params;\r\n\r\n  let zoom = d3.zoom()\r\n    .scaleExtent([1, 100])\r\n    .translateExtent([[-25, -25], [width, height]])\r\n    .on(\"start\", () => {\r\n      //console.log(\"zoom start\")  ;\r\n      setIsPanning(false);\r\n    })\r\n    .on(\"end\", () => {   \r\n      //console.log(\"zoom end\")  ;     \r\n      if(!isPanning){\r\n        // handleClick\r\n      }\r\n      setIsPanning(false);\r\n    })\r\n    .on(\"zoom\", (event) => {\r\n      let d = event.transform;\r\n      if (d.x !== 0 || d.y !== 0 || d.k !== 1) {\r\n          setIsPanning(true); // set to true if transformation detected\r\n          //console.log(\"setting panning to true\")  ;;\r\n      }\r\n      zoomed(event);\r\n    })\r\n  return {zoom};\r\n}\r\n\n\n//# sourceURL=webpack://d3-view-timeline/./src/utility.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./examples/example.js");
/******/ 	
/******/ })()
;